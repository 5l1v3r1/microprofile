<!DOCTYPE HTML>
<html>
<head>
<title>MicroProfile Capture</title>
<style>
/* about css: http://bit.ly/1eMQ42U */
body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#474747; color:white;overflow:hidden;}
ul {list-style-type: none;margin: 0;padding: 0;}
li{display: inline; float:left;border:5px; position:relative;text-align:center;}
a {
    float:left;
    text-decoration:none;
    display: inline;
    text-align: center;
	padding:5px;
	padding-bottom:0px;
	padding-top:0px;
    color: #FFFFFF;
    background-color: #474747;
}
a:hover, a:active{
	background-color: #000000;
}

ul ul {
    position:absolute;
    left:0;
    top:100%;
    margin-left:-999em;
}
li:hover ul {
    margin-left:0;
    margin-right:0;
}
ul li ul{ display:block;float:none;width:100%;}
ul li ul li{ display:block;float:none;width:100%;}
li li a{ display:block;float:none;width:100%;text-align:left;}
#nav li:hover div {margin-left:0;}
.help {position:absolute;z-index:5;text-align:left;padding:2px;margin-left:-999em;background-color: #313131;}
.root {z-index:1;position:absolute;top:0px;left:0px;}
</style>
</head>
<body style="">
<canvas id="History" height="70" style="background-color:#474747;margin:0px;padding:0px;"></canvas><canvas id="DetailedView" height="200" style="background-color:#474747;margin:0px;padding:0px;"></canvas>
<div id="root" class="root">
<ul id="nav">
<li><a href="#" onclick="ToggleDebugMode();">?</a>
<div class="help" style="left:20px;top:20px;width:220px;">
Use Cursor to Inspect<br>
Shift-Drag to Pan view<br>
Ctrl-Drag to Zoom view<br>
Click to Zoom to selected range<br>
</div>

<div class="help" id="divFrameInfo" style="left:20px;top:300px;width:auto;">
</div>

</li>
<li><a href="#" onclick="SetMode('timers');" id="buttonTimers">Timers</a> 
<li><a href="#" onclick="SetMode('timers', 1);" id="buttonGroups">Groups</a> 
<li><a href="#" onclick="SetMode('detailed');" id="buttonDetailed">Detailed</a> 
</li>
<li><a href="#">Reference</a>
    <ul id='ReferenceSubMenu'>
        <li><a href="#" onclick="SetReferenceTime('5ms');">5ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('10ms');">10ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('15ms');">15ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('20ms');">20ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('33ms');">33ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('50ms');">50ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('100ms');">100ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('250ms');">250ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('500ms');">500ms</a></li>
        <li><a href="#" onclick="SetReferenceTime('1000ms');">1000ms</a></li>
    </ul>
</li>
<li id="ilThreads"><a href="#">Threads</a>
    <ul id="ThreadSubMenu">
        <li><a href="#" onclick="ToggleThread();">All</a></li>
        <li><a href="#">---</a></li>
    </ul>
</li>
<li id="ilGroups"><a href="#">Groups</a>
    <ul id="GroupSubMenu">
        <li><a href="#" onclick="ToggleGroup();">All</a></li>
        <li><a href="#">---</a></li>
    </ul>
</li>
<li id="ilContextSwitch"><a href="#">ContextSwitch</a>
    <ul id='ContextSwitchMenu'>
        <li><a href="#" onclick="SetContextSwitch(1);">On</a></li>
        <li><a href="#" onclick="SetContextSwitch(0);">Off</a></li>
<!--      	<li><a href="#" onclick="ToggleDebug();">DEBUG</a></li> -->
    </ul>
</li>
<li id="ilTimersOptions"><a href="#">Options&nbsp;&nbsp;&nbsp;</a>
    <ul id='TimersOptions'>
        <li id='TimersMeta'><a href="#" onclick="ToggleTimersMeta();">Meta</a></li>
    </ul>
</li>


</ul>

</div>

<script>
function InvertColor(hexTripletColor) {
	var color = hexTripletColor;
	color = color.substring(1); // remove #
	color = parseInt(color, 16); // convert to integer
	var R = ((color >> 16) % 256)/255.0;
	var G = ((color >> 8) % 256)/255.0;
	var B = ((color >> 0) % 256)/255.0;
	var lum = (0.2126*R + 0.7152*G + 0.0722*B);
	if(lum < 0.7)
	{
		return '#ffffff';
	}
	else
	{
		return '#333333';
	}
}
function InvertColorIndex(hexTripletColor) {
	var color = hexTripletColor;
	color = color.substring(1); // remove #
	color = parseInt(color, 16); // convert to integer
	var R = ((color >> 16) % 256)/255.0;
	var G = ((color >> 8) % 256)/255.0;
	var B = ((color >> 0) % 256)/255.0;
	var lum = (0.2126*R + 0.7152*G + 0.0722*B);
	if(lum < 0.7)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}
function MakeGroup(id, name, numtimers, isgpu, average, max)
{
	var group = {"id":id, "name":name, "numtimers":numtimers, "isgpu":isgpu, "average" : average, "max" : max};
	return group;
}

function MakeTimer(id, name, group, color, average, max, exclaverage, exclmax, callaverage, callcount, meta)
{
	var timer = {"id":id, "name":name, "len":name.length, "color":color, "textcolor":InvertColor(color), "group":group, "average":average, "max":max, "exclaverage":exclaverage, "exclmax":exclmax, "callaverage":callaverage, "callcount":callcount, "meta":meta, "textcolorindex":InvertColorIndex(color)};
	return timer;
}
function MakeFrame(id, framestart, frameend, ts, tt, ti)
{
	var frame = {"id":id, "framestart":framestart, "frameend":frameend, "ts":ts, "tt":tt, "ti":ti};
	return frame;
}

____embed____


var CanvasDetailedView = document.getElementById('DetailedView');
var CanvasHistory = document.getElementById('History');
var CanvasDetailedOffscreen = document.createElement('canvas');
var g_Msg = '0';

var Initialized = 0;
var fDetailedOffset = Frames[0].framestart;
var fDetailedRange = Frames[0].frameend - fDetailedOffset;
var nWidth = CanvasDetailedView.width;
var nHeight = CanvasDetailedView.height;
var ReferenceTime = 33;
var nHistoryHeight = 70;
var nOffsetY = 0;
var nOffsetBarsY = 0;
var nBarsWidth = 80;
var NameWidth = 200;
var MouseButtonState = [0,0,0,0,0,0,0,0];
var KeyShiftDown = 0;
var MouseDragButton = 0;
var KeyCtrlDown = 0;
var FlipToolTip = 0;
var DetailedViewMouseX = 0;
var DetailedViewMouseY = 0;
var HistoryViewMouseX = -1;
var HistoryViewMouseY = -1;
var MouseHistory = 0;
var MouseDetailed = 0;
var FontHeight = 10;
var FontWidth = 1;
var FontAscent = 3; //Set manually
var Font = 'Bold ' + FontHeight + 'px Courier New';
var BoxHeight = FontHeight + 2;
var ThreadsActive = new Object();
var ThreadsAllActive = 1;
var GroupsActive = new Object();
var GroupsAllActive = 1;
var nMinWidth = 0.01;//subpixel width
var nMinWidthPan = 1.0;//subpixel width when panning
var nContextSwitchEnabled = 1;

var nModDown = 0;
var g_MSG = 'no';
var nDrawCount = 0;
var nBackColors = ['#474747', '#313131' ];
var nBackColorOffset = '#606060';
var CSwitchColors =["#9DD8AF","#D7B6DA","#EAAC76","#DBDA61","#8AD5E1","#8CE48B","#C4D688","#57E5C4"];//generated by http://tools.medialab.sciences-po.fr/iwanthue/index.php
var CSwitchHeight = 5;
var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
var FRAME_HISTORY_COLOR_GPU = '#ffffff';
var ZOOM_TIME = 0.5;
var AnimationActive = false;
var nHoverCSCpu = -1;
var nHoverCSCpuNext = -1;
var nHoverCSToolTip = null;
var nHoverToken = -1;
var nHoverFrame = -1;
var nHoverTokenIndex = -1;
var nHoverTokenLogIndex = -1;
var nHoverCounter = 0;
var nHoverCounterDelta = 8;
var nHoverTokenNext = -1;
var nHoverTokenLogIndexNext = -1;
var nHoverTokenIndexNext = -1;



var fFrameScale = 33.33;
var fRangeBegin = 0;
var fRangeEnd = -1;
var fRangeBeginNext = 0;
var fRangeEndNext = 0;
var fRangeBeginHistory = -1;
var fRangeEndHistory = -1;

var ModeDetailed = 0;
var ModeTimers = 1;
var Mode = ModeDetailed;

var DebugDrawQuadCount = 0;
var DebugDrawTextCount = 0;
var ProfileMode = 0;
var ProfileFps = 0;
var ProfileFpsAggr = 0;
var ProfileFpsCount = 0;
var ProfileLastTimeStamp = new Date();

var CSwitchCache = {};
var ProfileData = {};
var ProfileStackTime = {};
var ProfileStackName = {};
var Debug = 1;

var g_MaxStack = Array();
var g_TypeArray;
var g_TimeArray;
var g_IndexArray;
var LodData = new Array();
var NumLodSplits = 10;
var SplitMin = 100;
var SPLIT_LIMIT = 1e20;
var DPR = 1;
var DetailedRedrawState = {};
var OffscreenData;
var DetailedFrameCounter = 0;
var Invalidate = 0;
var GroupOrder = Array();
var ThreadOrder = Array();
var TimersGroups = 0;
var TimersMeta = 1;


function ProfileModeClear()
{
	if(ProfileMode)
	{
		ProfileData = new Object();
		ProfileStackTime = new Array();
		ProfileStackName = new Array();
	}
}
function ProfileEnter(Name)
{
	if(ProfileMode)
	{
		ProfileStackTime.push(new Date());
		ProfileStackName.push(Name);
	}
}
function ProfileLeave()
{
	if(ProfileMode)
	{
		var Time = new Date();
		var Delta = Time - ProfileStackTime.pop();
		var Name = ProfileStackName.pop();
		var Obj = ProfileData[Name];
		if(!Obj)
		{
			Obj = new Object();
			Obj.Count = 0;
			Obj.Name = Name;
			Obj.Time = 0;
			ProfileData[Name] = Obj;
		}
		Obj.Time += Delta;
		Obj.Count += 1;
	}
}

function ProfilePlot(s)
{
	if(ProfileMode)
	{
		var A = ProfileData.Plot;
		if(!A)
		{
			ProfileData.Plot = Array();
			A = ProfileData.Plot;
		}
		if(A.length<10)
		{
			A.push(s);
		}
	}
}
function ProfileModeDump()
{
	for(var idx in ProfileData)
	{
		var Timer = ProfileData[idx];
		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
	}

}
function ProfileModeDraw(Canvas)
{
	if(ProfileMode)
	{
		var StringArray = [];
		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			StringArray.push(Timer.Name);
			StringArray.push(Timer.Time + "ms");
			StringArray.push("#");
			StringArray.push("" + Timer.Count);
		}
		StringArray.push("debug");
		StringArray.push(Debug);
		var Time = new Date();
		var Delta = Time - ProfileLastTimeStamp;
		ProfileLastTimeStamp = Time;
		StringArray.push("Frame Delta");
		StringArray.push(Delta + "ms");
		if(ProfileMode == 2)
		{
			ProfileFpsAggr += Delta;
			ProfileFpsCount ++ ;
			var AggrFrames = 10;
			if(ProfileFpsCount == AggrFrames)
			{
				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
				ProfileFpsAggr = 0;
				ProfileFpsCount = 0;
			}
			StringArray.push("FPS");
			StringArray.push("" + ProfileFps.toFixed(2));
		}


		for(var i = 0; i < ProfileData.Plot; ++i)
		{
			StringArray.push("");
			StringArray.push(ProfileData.Plot[i]);
		}
		ProfileData.Plot = Array();
		DrawToolTip(StringArray, Canvas, 0, 200);
	}
}

function ToggleDebugMode()
{
	ProfileMode = (ProfileMode+1)%4;
	console.log('Toggle Debug Mode ' + ProfileMode);
}

function DetailedTotal()
{
	var Total = 0;
	for(var i = 0; i < Frames.length; i++)
	{
		var frfr = Frames[i];
		Total += frfr.frameend - frfr.framestart;
	}
	return Total;
}

function InitFrameInfo()
{

	var div = document.getElementById('divFrameInfo');
	var txt = '';
	txt = txt + 'Timers View' + '<br>';
	txt = txt + 'Frames:' + AggregateInfo.Frames +'<br>';
	txt = txt + 'Time:' + AggregateInfo.Time.toFixed(2) +'ms<br>';
	txt = txt + '<hr>';
	txt = txt + 'Detailed View' + '<br>';
	txt = txt + 'Frames:' + Frames.length +'<br>';
	txt = txt + 'Time:' + DetailedTotal().toFixed(2) +'ms<br>';
	div.innerHTML = txt;
}
function InitGroups()
{
	for(groupid in GroupInfo)
	{
		var TimerArray = Array();
		for(timerid in TimerInfo)
		{
			if(TimerInfo[timerid].group == groupid)
			{
				TimerArray.push(timerid);
			}
		}
		GroupInfo[groupid].TimerArray = TimerArray;
	}
}

function InitThreadMenu()
{
	var ulThreadMenu = document.getElementById('ThreadSubMenu');
	var MaxLen = 7;
	ThreadOrder = CreateOrderArray(ThreadNames, function(a){return a;});
	for(var idx in ThreadOrder)
	{
		var name = ThreadNames[ThreadOrder[idx]];
		var li = document.createElement('li');
		if(name.length > MaxLen)
		{
			MaxLen = name.length;
		}
		li.innerText = name;
		var asText = li.innerHTML;
		var html = '<a href="#" onclick="ToggleThread(\'' + name + '\');">' + asText + '</a>';
		li.innerHTML = html;
		ulThreadMenu.appendChild(li);
	}
	var LenStr = (5+(1+MaxLen) * (1+FontWidth)) + 'px';
	var Lis = ulThreadMenu.getElementsByTagName('li');
	for(var i = 0; i < Lis.length; ++i)
	{
		Lis[i].style['width'] = LenStr;
	}
}

function UpdateThreadMenu()
{
	var ulThreadMenu = document.getElementById('ThreadSubMenu');
	var as = ulThreadMenu.getElementsByTagName('a');
	for(var i = 0; i < as.length; ++i)
	{
		var elem = as[i];
		var inner = elem.innerText;
		var bActive = false;
		if(i < 2)
		{
			if(inner == 'All')
			{
				bActive = ThreadsAllActive;
			}
		}
		else
		{
			bActive = ThreadsActive[inner];
		}
		if(bActive)
		{
			elem.style['text-decoration'] = 'underline';
		}
		else
		{
			elem.style['text-decoration'] = 'none';
		}
	}
}

function ToggleThread(ThreadName)
{
	if(ThreadName)
	{
		if(ThreadsActive[ThreadName])
		{
			ThreadsActive[ThreadName] = false;
		}
		else
		{
			ThreadsActive[ThreadName] = true;
		}
	}
	else
	{
		if(ThreadsAllActive)
		{
			ThreadsAllActive = 0;
		}
		else
		{
			ThreadsAllActive = 1;
		}
	}
	Invalidate = 0;
	UpdateThreadMenu();
	WriteCookie();
	Draw();

}

function CreateOrderArray(Source, NameFunc)
{
	var Temp = Array(Source.length);
	for(var i = 0; i < Source.length; ++i)
	{
		Temp[i] = {};
		Temp[i].index = i;
		Temp[i].namezz = NameFunc(Source[i]).toLowerCase();
	}
	Temp.sort(function(l, r)
	{ 
		if(r.namezz<l.namezz)
			{return 1;}
		if(l.namezz<r.namezz)
			{return -1;} 
		return 0;
	} );
	var OrderArray = Array(Source.length);
	for(var i = 0; i < Source.length; ++i)
	{
		OrderArray[i] = Temp[i].index;
	}
	return OrderArray;
}


function InitGroupMenu()
{
	var ulGroupMenu = document.getElementById('GroupSubMenu');
	var MaxLen = 7;

	GroupOrder = CreateOrderArray(GroupInfo, function(a){ return a.name; } );

	for(var idx in GroupOrder)
	{
		var name = GroupInfo[GroupOrder[idx]].name;
		var li = document.createElement('li');
		if(name.length > MaxLen)
		{
			MaxLen = name.length;
		}
		li.innerText = name;
		var asText = li.innerHTML;
		var html = '<a href="#" onclick="ToggleGroup(\'' + name + '\');">' + asText + '</a>';
		li.innerHTML = html;
		ulGroupMenu.appendChild(li);
	}
	var LenStr = (5+(1+MaxLen) * FontWidth) + 'px';
	var Lis = ulGroupMenu.getElementsByTagName('li');
	for(var i = 0; i < Lis.length; ++i)
	{
		Lis[i].style['width'] = LenStr;
	}
	UpdateGroupMenu();
}

function UpdateGroupMenu()
{
	var ulThreadMenu = document.getElementById('GroupSubMenu');
	var as = ulThreadMenu.getElementsByTagName('a');
	for(var i = 0; i < as.length; ++i)
	{
		var elem = as[i];
		var inner = elem.innerText;
		var bActive = false;
		if(i < 2)
		{
			if(inner == 'All')
			{
				bActive = GroupsAllActive;
			}
		}
		else
		{
			bActive = GroupsActive[inner];
		}
		if(bActive)
		{
			elem.style['text-decoration'] = 'underline';
		}
		else
		{
			elem.style['text-decoration'] = 'none';
		}
	}
}


function ToggleGroup(GroupName)
{
	if(GroupName)
	{
		if(GroupsActive[GroupName])
		{
			GroupsActive[GroupName] = false;
		}
		else
		{
			GroupsActive[GroupName] = true;
		}
	}
	else
	{
		if(GroupsAllActive)
		{
			GroupsAllActive = 0;
		}
		else
		{
			GroupsAllActive = 1;
		}
	}
	UpdateGroupMenu();
	WriteCookie();
	RequestRedraw();

}

function UpdateTimersOptions()
{
	var ulTimersMeta = document.getElementById('TimersMeta');
	ulTimersMeta.style['text-decoration'] = TimersMeta ? 'underline' : 'none';

}

function ToggleTimersMeta()
{
	TimersMeta = TimersMeta ? 0 : 1;
	WriteCookie();
	UpdateTimersOptions();
	Invalidate = 0;
}

function SetMode(NewMode, Groups)
{
	var buttonTimers = document.getElementById('buttonTimers');
	var buttonDetailed = document.getElementById('buttonDetailed');
	var buttonGroups = document.getElementById('buttonGroups');
	var ilThreads = document.getElementById('ilThreads');
	var ilGroups = document.getElementById('ilGroups');
	var ilContextSwitch = document.getElementById('ilContextSwitch');
	var ilTimersOptions = document.getElementById('ilTimersOptions');
	if(NewMode == 'timers' || NewMode == ModeTimers)
	{
		if(Groups)
		{
			TimersGroups = 1;
			buttonTimers.style['text-decoration'] = 'none';
			buttonGroups.style['text-decoration'] = 'underline';
		}
		else
		{
			TimersGroups = 0;
			buttonTimers.style['text-decoration'] = 'underline';
			buttonGroups.style['text-decoration'] = 'none';
		}
		buttonDetailed.style['text-decoration'] = 'none';
		ilThreads.style['display'] = 'none';
		ilContextSwitch.style['display'] = 'none';
		ilGroups.style['display'] = 'block';
		ilTimersOptions.style['display'] = 'block';
		Mode = ModeTimers;
	}
	else if(NewMode == 'detailed' || NewMode == ModeDetailed)
	{
		buttonTimers.style['text-decoration'] = 'none';
		buttonGroups.style['text-decoration'] = 'none';
		buttonDetailed.style['text-decoration'] = 'underline';
		ilThreads.style['display'] = 'block';
		ilGroups.style['display'] = 'none';
		ilContextSwitch.style['display'] = 'block';
		ilTimersOptions.style['display'] = 'none';
		Mode = ModeDetailed;
	}
	WriteCookie();
	RequestRedraw();

}

function SetReferenceTime(TimeString)
{
	ReferenceTime = parseInt(TimeString);
	var ReferenceMenu = document.getElementById('ReferenceSubMenu');
	var Links = ReferenceMenu.getElementsByTagName('a');
	for(var i = 0; i < Links.length; ++i)
	{
		if(Links[i].innerHTML.match('^' + TimeString))
		{
			Links[i].style['text-decoration'] = 'underline';
		}
		else
		{
			Links[i].style['text-decoration'] = 'none';
		}
	}
	WriteCookie();
	RequestRedraw();

}

function SetContextSwitch(Enabled)
{
	nContextSwitchEnabled = Enabled ? 1 : 0;
	var ReferenceMenu = document.getElementById('ContextSwitchMenu');
	var Links = ReferenceMenu.getElementsByTagName('a');
	if(nContextSwitchEnabled)
	{
		Links[0].style['text-decoration'] = 'underline';
		Links[1].style['text-decoration'] = 'none';
	}
	else
	{
		Links[0].style['text-decoration'] = 'none';	
		Links[1].style['text-decoration'] = 'underline';		
	}
	WriteCookie();
	RequestRedraw();
}

function ToggleDebug()
{
	Debug = (Debug + 1) % 2;
}

function GatherHoverMetaCounters(TimerIndex, StartIndex, nLog, nFrameLast)
{
	var HoverInfo = new Object();
	var StackPos = 1;
	//search backwards, count meta counters 
	for(var i = nFrameLast; i >= 0; i--)
	{
		var fr = Frames[i];
		var ts = fr.ts[nLog];
		var ti = fr.ti[nLog];
		var tt = fr.tt[nLog];
		var start = i == nFrameLast ? StartIndex-1 : ts.length-1;

		for(var j = start; j >= 0; j--)
		{
			var type = tt[j];
			var index = ti[j];
			var time = ts[j];
			if(type == 1)
			{
				StackPos--;
				if(StackPos == 0 && index == TimerIndex)
				{
					return HoverInfo;
				}
			}
			else if(type == 0)
			{
				StackPos++;
			}
			else
			{
				var nMetaCount = type - 2;
				var nMetaIndex = MetaNames[index];
				if(nMetaIndex in HoverInfo)
				{
					HoverInfo[nMetaIndex] += nMetaCount;
				}
				else
				{
					HoverInfo[nMetaIndex] = nMetaCount;
				}
			}
		}
	}

}
function CalculateTimers(Result, TimerIndex, nFrameFirst, nFrameLast)
{
	if(!nFrameFirst || nFrameFirst < 0)
		nFrameFirst = 0;
	if(!nFrameLast || nFrameLast > Frames.length)
		nFrameLast = Frames.length;
	var FrameCount = nFrameLast - nFrameFirst;
	if(0 == FrameCount)
		return;
	var CallCount = 0;
	var Sum = 0;
	var Max = 0;
	var FrameMax = 0;

	var nNumLogs = Frames[0].ts.length;
	var StackPosArray = Array(nNumLogs);
	var StackArray = Array(nNumLogs);
	for(var i = 0; i < nNumLogs; ++i)
	{
		StackPosArray[i] = 0;
		StackArray[i] = Array(20);
	}

	for(var i = nFrameFirst; i < nFrameLast; i++)
	{
		var FrameSum = 0;
		var fr = Frames[i];
		for(nLog = 0; nLog < nNumLogs; nLog++)
		{
			var StackPos = StackPosArray[nLog];
			var Stack = StackArray[nLog];
			var ts = fr.ts[nLog];
			var ti = fr.ti[nLog];
			var tt = fr.tt[nLog];
			var count = ts.length;
			for(j = 0; j < count; j++)
			{
				var type = tt[j];
				var index = ti[j];
				var time = ts[j];
				if(type == 1) //enter
				{
					//push
					Stack[StackPos] = time;
					if(StackArray[nLog][StackPos] != time)
					{
						console.log('fail fail fail');
					}
					StackPos++;
				}
				else if(type == 0) // leave
				{
					var timestart;
					var timeend = time;
					if(StackPos>0)
					{
						StackPos--;
						timestart = Stack[StackPos];
					}
					else
					{
						timestart = Frames[nFrameFirst].framestart;
					}
					if(index == TimerIndex)
					{
						var TimeDelta = timeend - timestart;
						CallCount++;
						FrameSum += TimeDelta;
						Sum += TimeDelta;
						if(TimeDelta > Max)
							Max = TimeDelta;
					}
				}
				else
				{
					//meta
				}
			}
			if(FrameSum > FrameMax)
			{
				FrameMax = FrameSum;
			}
			StackPosArray[nLog] = StackPos;
		}
	}

	Result.CallCount = CallCount;
	Result.Sum = Sum.toFixed(3);
	Result.Max = Max.toFixed(3);
	Result.Average = (Sum / CallCount).toFixed(3);
	Result.FrameAverage = (Sum / FrameCount).toFixed(3);
	Result.FrameCallAverage = (CallCount / FrameCount).toFixed(3);
	Result.FrameMax = FrameMax.toFixed(3);
	return Result;

}

function DrawDetailedFrameHistory()
{
	ProfileEnter("DrawDetailedFrameHistory");
	var x = HistoryViewMouseX;

	var context = CanvasHistory.getContext('2d');
	context.clearRect(0, 0, CanvasHistory.width, CanvasHistory.height);

	var fHeight = nHistoryHeight;
	var fWidth = nWidth / Frames.length;
	var fHeightScale = fHeight / ReferenceTime;
	var fX = 0;
	var FrameIndex = -1;
	var MouseDragging = MouseDragState != MouseDragOff;
	fRangeBeginHistory = fRangeEndHistory = -1;

	var FrameFirst = -1;
	var FrameLast = nWidth;
	var fDetailedOffsetEnd = fDetailedOffset + fDetailedRange;
	for(i = 0; i < Frames.length; i++)
	{
		var fMs = Frames[i].frameend - Frames[i].framestart;
		if(fDetailedOffset <= Frames[i].frameend && fDetailedOffset >= Frames[i].framestart)
		{
			var lerp = (fDetailedOffset - Frames[i].framestart) / (Frames[i].frameend - Frames[i].framestart);
			FrameFirst = fX + fWidth * lerp;
		}
		if(fDetailedOffsetEnd <= Frames[i].frameend && fDetailedOffsetEnd >= Frames[i].framestart)
		{
			var lerp = (fDetailedOffsetEnd - Frames[i].framestart) / (Frames[i].frameend - Frames[i].framestart);
			FrameLast = fX + fWidth * lerp;
		}
		var fH = fHeightScale * fMs;
		var bMouse = x > fX && x < fX + fWidth;
		if(bMouse && !MouseDragging)
		{
			context.fillStyle = FRAME_HISTORY_COLOR_GPU;
			fRangeBeginHistory = Frames[i].framestart;
			fRangeEndHistory = Frames[i].frameend;
			FrameIndex = i;
		}
		else
		{
			context.fillStyle = FRAME_HISTORY_COLOR_CPU;
		}
		context.fillRect(fX, fHeight - fH, fWidth-1, fH);
		fX += fWidth;
	}

	var fRangeHistoryBegin = FrameFirst;
	var fRangeHistoryEnd = FrameLast;
	var X = fRangeHistoryBegin;
	var Y = 0;
	var W = fRangeHistoryEnd - fRangeHistoryBegin;
	context.globalAlpha = 0.35;
	context.fillStyle = '#009900';
	context.fillRect(X, Y, W, fHeight);
	context.globalAlpha = 1;
	context.strokeStyle = '#00ff00';
	context.beginPath();
	context.moveTo(X, Y);
	context.lineTo(X, Y+fHeight);
	context.moveTo(X+W, Y);
	context.lineTo(X+W, Y+fHeight);
	context.stroke();

	if(FrameIndex>=0 && !MouseDragging)
	{
		var StringArray = [];
		StringArray.push("Frame");
		StringArray.push("" + FrameIndex);
		StringArray.push("Time");
		StringArray.push("" + (Frames[FrameIndex].frameend - Frames[FrameIndex].framestart).toFixed(3));

		DrawToolTip(StringArray, CanvasHistory, HistoryViewMouseX, HistoryViewMouseY+20);

	}
	ProfileLeave();
}

function DrawDetailedBackground(context)
{
	var fMs = fDetailedRange;
	var fMsEnd = fMs + fDetailedOffset;
	var fMsToScreen = nWidth / fMs;
	var fRate = Math.floor(2*((Math.log(fMs)/Math.log(10))-1))/2;
	var fStep = Math.pow(10, fRate);
	var fRcpStep = 1.0 / fStep;
	var nColorIndex = Math.floor(fDetailedOffset * fRcpStep) % 2;
	if(nColorIndex < 0)
		nColorIndex = -nColorIndex;
	var fStart = Math.floor(fDetailedOffset * fRcpStep) * fStep;
	var fHeight = CanvasDetailedView.height;
	var fScaleX = nWidth / fDetailedRange; 
	for(f = fStart; f < fMsEnd; )
	{
		var fNext = f + fStep;
		var X = (f - fDetailedOffset) * fScaleX;
		var W = (fNext-f)*fScaleX;
		context.fillStyle = nBackColors[nColorIndex];
		context.fillRect(X, 0, W+2, fHeight);
		nColorIndex = 1 - nColorIndex;
		f = fNext;
	}
	var fScaleX = nWidth / fDetailedRange; 
	context.globalAlpha = 0.5;
	context.strokeStyle = '#bbbbbb';
	context.beginPath();
	for(var i = 0; i < Frames.length; i++)
	{
		var frfr = Frames[i];
		if(frfr.frameend < fDetailedOffset || frfr.framestart > fDetailedOffset + fDetailedRange)
		{
			continue;
		}
		var X = (frfr.framestart - fDetailedOffset) * fScaleX;
		if(X >= 0 && X < nWidth)
		{
			context.moveTo(X, 0);
			context.lineTo(X, nHeight);
		}
	}
	context.stroke();
	context.globalAlpha = 1;

}
function DrawToolTip(StringArray, Canvas, x, y)
{
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(StringArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;
	for(i = 0; i < StringArray.length; i += 2)
	{
		var nWidth0 = context.measureText(StringArray[i]).width;
		var nWidth1 = context.measureText(StringArray[i+1]).width;
		var nSum = nWidth0 + nWidth1;
		WidthArray[i] = nWidth0;
		WidthArray[i+1] = nWidth1;
		if(nSum > nMaxWidth)
		{
			nMaxWidth = nSum;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	//bounds check.
	var CanvasRect = Canvas.getBoundingClientRect();
	if(y + nHeight > CanvasRect.height)
	{
		y = CanvasRect.height - nHeight;
		x += 20;
	}
	if(x + nMaxWidth > CanvasRect.width)
	{
		x = CanvasRect.width - nMaxWidth;
	}

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < StringArray.length; i += 2)
	{
		context.fillText(StringArray[i], XPos, YPos);
		context.fillText(StringArray[i+1], XPosRight - WidthArray[i+1], YPos);
		YPos += BoxHeight;
	}
}
function DrawHoverToolTip()
{
	ProfileEnter("DrawHoverToolTip");
	if(nHoverToken != -1)
	{
		var StringArray = [];
		var groupid = TimerInfo[nHoverToken].group;
		StringArray.push("Timer");
		StringArray.push(TimerInfo[nHoverToken].name);
		StringArray.push("Group");
		StringArray.push(GroupInfo[groupid].name);

		var bShowTimers = Mode == ModeTimers;
		if(FlipToolTip)
		{
			bShowTimers = !bShowTimers;
		}
		if(bShowTimers)
		{

			StringArray.push("");
			StringArray.push("");
			var Timer = TimerInfo[nHoverToken];
			StringArray.push("Average");
			StringArray.push(Timer.average);
			StringArray.push("Max");
			StringArray.push(Timer.max);
			StringArray.push("Excl Max");
			StringArray.push(Timer.exclmax);
			StringArray.push("Excl Average");
			StringArray.push(Timer.exclaverage);
			StringArray.push("Call Average");
			StringArray.push(Timer.callaverage);
			StringArray.push("Call Count");
			StringArray.push(Timer.callcount);

			StringArray.push("");
			StringArray.push("");


			StringArray.push("Group");
			StringArray.push(GroupInfo[groupid].name);
			StringArray.push("Average");
			StringArray.push(GroupInfo[groupid].average);
			StringArray.push("Max");
			StringArray.push(GroupInfo[groupid].max);

			StringArray.push("");
			StringArray.push("");

			StringArray.push("Timer Capture");
			StringArray.push("");
			StringArray.push("Frames");
			StringArray.push(AggregateInfo.Frames);
			StringArray.push("Time");
			StringArray.push(AggregateInfo.Time.toFixed(2) + "ms");




		}
		else
		{
			StringArray.push("");
			StringArray.push("");



			StringArray.push("Time");
			StringArray.push((fRangeEnd-fRangeBegin).toFixed(3));
			StringArray.push("");
			StringArray.push("");
			StringArray.push("Total");
			StringArray.push("" + TimerInfo[nHoverToken].Sum);
			StringArray.push("Max");
			StringArray.push("" + TimerInfo[nHoverToken].Max);
			StringArray.push("Average");
			StringArray.push("" + TimerInfo[nHoverToken].Average);
			StringArray.push("Count");
			StringArray.push("" + TimerInfo[nHoverToken].CallCount);

			StringArray.push("");
			StringArray.push("");

			StringArray.push("Max/Frame");
			StringArray.push("" + TimerInfo[nHoverToken].FrameMax);

			StringArray.push("Average Time/Frame");
			StringArray.push("" + TimerInfo[nHoverToken].FrameAverage);

			StringArray.push("Average Count/Frame");
			StringArray.push("" + TimerInfo[nHoverToken].FrameCallAverage);





		
			if(nHoverFrame != -1)
			{
				StringArray.push("");
				StringArray.push("");
				StringArray.push("Frame " + nHoverFrame);
				StringArray.push("");

				var FrameTime = new Object();
				CalculateTimers(FrameTime, nHoverToken, nHoverFrame, nHoverFrame+1);
				StringArray.push("Total");
				StringArray.push("" + FrameTime.Sum);
				StringArray.push("Count");
				StringArray.push("" + FrameTime.CallCount);
				StringArray.push("Average");
				StringArray.push("" + FrameTime.Average);
				StringArray.push("Max");
				StringArray.push("" + FrameTime.Max);
			}

			var HoverInfo = GatherHoverMetaCounters(nHoverToken, nHoverTokenIndex, nHoverTokenLogIndex, nHoverFrame);
			var Header = 0;
			for(index in HoverInfo)
			{
				if(0 == Header)
				{
					Header = 1;
					StringArray.push("");
					StringArray.push("");
					StringArray.push("Meta");
					StringArray.push("");

				}
				StringArray.push(""+index);
				StringArray.push(""+HoverInfo[index]);
			}

			StringArray.push("");
			StringArray.push("");

			StringArray.push("Detailed Capture");
			StringArray.push("");
			StringArray.push("Frames");
			StringArray.push(Frames.length);
			StringArray.push("Time");
			StringArray.push(DetailedTotal().toFixed(2) + "ms");


		}
		DrawToolTip(StringArray, CanvasDetailedView, DetailedViewMouseX, DetailedViewMouseY+20);
	}
	else if(nHoverCSCpu >= 0)
	{
		var StringArray = [];
		StringArray.push("Context Switch");
		StringArray.push("");
		StringArray.push("");
		StringArray.push("");
		StringArray.push("Cpu");
		StringArray.push("" + nHoverCSCpu);
		StringArray.push("Begin");
		StringArray.push("" + fRangeBegin);
		StringArray.push("End");
		StringArray.push("" + fRangeEnd);
		DrawToolTip(StringArray, CanvasDetailedView, DetailedViewMouseX, DetailedViewMouseY+20);
	}
	ProfileLeave();
}


function DrawBarView()
{
	ProfileEnter("DrawBarView");
	Invalidate++;
	nHoverToken = -1;
	nHoverFrame = -1;
	var context = CanvasDetailedView.getContext('2d');
	context.clearRect(0, 0, nWidth, nHeight);

	var Height = BoxHeight;
	var Width = nWidth;

	//clamp offset to prevent scrolling into the void
	var nTotalRows = 0;
	for(var groupid in GroupInfo)
	{
		if(GroupsAllActive || GroupsActive[GroupInfo[groupid].name])
		{
			nTotalRows += GroupInfo[groupid].TimerArray.length + 1;
		}
	}
	var nTotalRowPixels = nTotalRows * Height;
	var nFrameRows = nHeight - BoxHeight;
	if(nOffsetBarsY + nFrameRows > nTotalRowPixels && nTotalRowPixels > nFrameRows)
	{
		nOffsetBarsY = nTotalRowPixels - nFrameRows;
	}


	var Y = -nOffsetBarsY + BoxHeight;
	var nColorIndex = 0;

	context.fillStyle = 'white';
	context.font = Font;
	var bMouseIn = 0;
	var RcpReferenceTime = 1.0 / ReferenceTime;
	var CountWidth = 8 * FontWidth;
	var nMetaLen = TimerInfo[0].meta.length;
	var nMetaCharacters = 10;
	for(var i = 0; i < nMetaLen; ++i)
	{
		if(nMetaCharacters < MetaNames[i].length)
			nMetaCharacters = MetaNames[i].length;
	}
	var nWidthMeta = nMetaCharacters * FontWidth + 6;
	function DrawHeaderSplit(Header)
	{
		context.fillStyle = 'white';
		context.fillText(Header, X, Height-FontAscent);
		X += nWidthBars;
		context.fillStyle = nBackColorOffset;
		X += nWidthMs;
		context.fillRect(X-3, 0, 1, nHeight);
	}
	function DrawHeaderSplitSingle(Header, Width)
	{
		context.fillStyle = 'white';
		context.fillText(Header, X, Height-FontAscent);
		X += Width;
		context.fillStyle = nBackColorOffset;
		context.fillRect(X-3, 0, 1, nHeight);
	}
	function DrawHeaderSplitLeftRight(HeaderLeft, HeaderRight, Width)
	{
		context.textAlign = 'left';
		context.fillStyle = 'white';
		context.fillText(HeaderLeft, X, Height-FontAscent);
		X += Width;
		context.textAlign = 'right';
		context.fillText(HeaderRight, X-5, Height-FontAscent);
		context.textAlign = 'left';
		context.fillStyle = nBackColorOffset;
		context.fillRect(X-3, 0, 1, nHeight);
	}
	function DrawTimer(Value, Color)
	{
		var Prc = Value * RcpReferenceTime;
		var YText = Y+Height-FontAscent;
		if(Prc > 1)
		{
			Prc = 1;
		}
		context.fillStyle = Color;
		context.fillRect(X+1, Y+1, Prc * nBarsWidth, InnerBoxHeight);
		X += nWidthBars;
		context.fillStyle = 'white';
		context.fillText(("      " + Value.toFixed(2)).slice(-TimerLen), X, YText);
		X += nWidthMs;
	}
	function DrawMeta(Value)
	{
		if(!Value)
		{
			Value = "0";
		}
		else
		{
			Value = '' + Value;
		}
		context.fillText(Value, X + nWidthMeta - 6 - Value.length * FontWidth, YText);
		X += nWidthMeta;
	}

	for(var idx in GroupOrder)
	{
		var groupid = GroupOrder[idx];
		var Group = GroupInfo[groupid];
		if(GroupsAllActive || GroupsActive[Group.name])
		{
			var TimerArray = Group.TimerArray;
			var InnerBoxHeight = BoxHeight-2;
			var TimerLen = 6;
			var TimerWidth = TimerLen * FontWidth;
			var nWidthBars = nBarsWidth+2;
			var nWidthMs = TimerWidth + 2 + 10;
			var X = 0;
			nColorIndex = 1-nColorIndex;
			bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
			context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
			context.fillRect(0, Y, Width, nHeight);
			context.fillStyle = 'white';
			context.fillText(Group.name, 1, Y+Height-FontAscent);
			X += NameWidth;
			DrawTimer(Group.average, 'white');
			DrawTimer(Group.max, 'white');
			Y += Height;
			if(TimersGroups)
			{
				for(var i = 0; i < ThreadNames.length; ++i)
				{
					var PerThreadTimer = ThreadGroupTimeArray[i][groupid];
					if(PerThreadTimer > 0.0001)
					{
						var YText = Y+Height-FontAscent;
						bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
						nColorIndex = 1-nColorIndex;
						context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
						context.fillRect(0, Y, Width, Height);
						var ThreadColor = CSwitchColors[i % CSwitchColors.length];
						context.fillStyle = ThreadColor;
						context.textAlign = 'right';
						context.fillText(ThreadNames[i], NameWidth - 5, YText);
						context.textAlign = 'left';

						X = NameWidth;
						DrawTimer(PerThreadTimer, ThreadColor);
						Y += Height;
					}
				}
			}
			else
			{

				for(var timerindex in TimerArray)
				{
					var timerid = TimerArray[timerindex];
					var Timer = TimerInfo[timerid];
					var Average = Timer.average;
					var Max = Timer.max;
					var ExclusiveMax = Timer.exclmax;
					var ExclusiveAverage = Timer.exclaverage;
					var CallAverage = Timer.callaverage;
					var CallCount = Timer.callcount;
					var YText = Y+Height-FontAscent;
					X = NameWidth;

					nColorIndex = 1-nColorIndex;
					bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
					if(bMouseIn)
					{
						nHoverToken = timerid;
					}
					context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
					context.fillRect(0, Y, Width, Height);

					context.textAlign = 'right';
					context.fillStyle = Timer.color;
					context.fillText(Timer.name, NameWidth - 5, YText);
					context.textAlign = 'left';

					DrawTimer(Average, Timer.color);
					DrawTimer(Max,Timer.color);
					DrawTimer(CallAverage,Timer.color);
					context.fillStyle = 'white';
					context.fillText(CallCount, X, YText);
					X += CountWidth;
					DrawTimer(ExclusiveAverage,Timer.color);
					DrawTimer(ExclusiveMax,Timer.color);

					if(TimersMeta)
					{
						context.fillStyle = 'white';
						for(var j = 0; j < nMetaLen; ++j)
						{
							DrawMeta(Timer.meta[j]);
						}
					}
					Y += Height;
				}			
			}
		}
	}
	X = 0;
	context.fillStyle = nBackColorOffset;
	context.fillRect(0, 0, Width, Height);
	context.fillStyle = 'white';
	if(TimersGroups)
	{
		DrawHeaderSplitLeftRight('Group', 'Thread', NameWidth);
		DrawHeaderSplit('Average');
		DrawHeaderSplit('Max');
	}
	else
	{
		DrawHeaderSplitLeftRight('Group', 'Timer', NameWidth);
		DrawHeaderSplit('Average');
		DrawHeaderSplit('Max');
		DrawHeaderSplit('Call Average');
		DrawHeaderSplitSingle('Count', CountWidth);
		DrawHeaderSplit('Excl Average');
		DrawHeaderSplit('Excl Max');
		if(TimersMeta)
		{
			for(var i = 0; i < nMetaLen; ++i)
			{
				DrawHeaderSplitSingle(MetaNames[i], nWidthMeta);
			}
		}
	}

	ProfileLeave();
}


function DrawContextSwitchBars(context, ThreadId, fScaleX, fOffsetY, fDetailedOffset, nHoverColor, MinWidth, bDrawEnabled)
{
	ProfileEnter("DrawContextSwitchBars");
	var CSObject = CSwitchCache[ThreadId];
	if(ThreadId > 0 && !CSObject)
	{
		CSArrayIn = new Array();
		CSArrayOut = new Array();
		CSArrayCpu = new Array();
		var nCount = CSwitchTime.length;
		var j = 0;
		var TimeIn = -1.0;
		for(var i = 0; i < nCount; ++i)
		{	
			var ThreadIn = CSwitchThreadInOutCpu[j];
			var ThreadOut = CSwitchThreadInOutCpu[j+1];
			var Cpu = CSwitchThreadInOutCpu[j+2];
			if(TimeIn < 0)
			{
				if(ThreadIn == ThreadId)
				{
					TimeIn = CSwitchTime[i];
				}
			}
			else
			{
				if(ThreadOut == ThreadId)
				{
					var TimeOut = CSwitchTime[i];
					CSArrayIn.push(TimeIn);
					CSArrayOut.push(TimeOut);
					CSArrayCpu.push(Cpu);
					TimeIn = -1;
				}
			}
			j += 3;
		}
		CSObject = new Object();
		CSObject.Size = CSArrayIn.length;
		CSObject.In = CSArrayIn;
		CSObject.Out = CSArrayOut;
		CSObject.Cpu = CSArrayCpu;
		CSwitchCache[ThreadId] = CSObject;
	}
	if(CSObject)
	{
		var Size = CSObject.Size;		
		var In = CSObject.In;
		var Out = CSObject.Out;
		var Cpu = CSObject.Cpu;
		var nNumColors = CSwitchColors.length;
		for(var i = 0; i < Size; ++i)
		{
			var TimeIn = In[i];
			var TimeOut = Out[i];
			var ActiveCpu = Cpu[i];

			var X = (TimeIn - fDetailedOffset) * fScaleX;
			if(X > nWidth)
			{
				break;
			}
			var W = (TimeOut - TimeIn) * fScaleX;
			if(W > MinWidth && X+W > 0)
			{
				if(nHoverCSCpu == ActiveCpu || bDrawEnabled)
				{
					if(nHoverCSCpu == ActiveCpu)
					{
						context.fillStyle = nHoverColor;
					}
					else
					{
						context.fillStyle = CSwitchColors[ActiveCpu % nNumColors];
					}
					context.fillRect(X, fOffsetY, W, CSwitchHeight);
				}
				if(DetailedViewMouseX >= X && DetailedViewMouseX <= X+W && DetailedViewMouseY < fOffsetY+CSwitchHeight && DetailedViewMouseY >= fOffsetY)
				{
					nHoverCSCpuNext = ActiveCpu;
					fRangeBeginNext = TimeIn;
					fRangeEndNext = TimeOut;
				}
			}
		}
	}
	ProfileLeave();
}

function DrawDetailedView(context, MinWidth, bDrawEnabled)
{
	if(bDrawEnabled)
	{
		DrawDetailedBackground(context);
	}

	var colors = [ '#ff0000', '#ff00ff', '#ffff00'];

	var fScaleX = nWidth / fDetailedRange; 
	var fOffsetY = -nOffsetY + BoxHeight;
	nHoverTokenNext = -1;
	nHoverTokenLogIndexNext = -1;
	nHoverTokenIndexNext = -1;
	nHoverCounter += nHoverCounterDelta;
	if(nHoverCounter >= 255) 
	{
		nHoverCounter = 255;
		nHoverCounterDelta = -nHoverCounterDelta;
	}
	if(nHoverCounter < 128) 
	{
		nHoverCounter = 128;
		nHoverCounterDelta = -nHoverCounterDelta;
	}
	var nHoverHigh = nHoverCounter.toString(16);
	var nHoverLow = (127+255-nHoverCounter).toString(16);
	var nHoverColor = '#' + nHoverHigh + nHoverHigh + nHoverHigh;

	context.fillStyle = 'black';
	context.font = Font;
	var nNumLogs = Frames[0].ts.length;
	var fTimeEnd = fDetailedOffset + fDetailedRange;

	var FirstFrame = Frames.length-1;
	for(var i = Frames.length-1; i > 0 ; --i)
	{
		if(Frames[i].framestart > fDetailedOffset)
		{
			FirstFrame = i-1;
		}
	}

	var nMinTimeMs = MinWidth / fScaleX;
	{

		var Batches = new Array(TimerInfo.length);
		var BatchesTxt = Array();
		var BatchesTxtPos = Array();
		var BatchesTxtColor = ['#ffffff', '#333333'];

		for(var i = 0; i < 2; ++i)
		{
			BatchesTxt[i] = Array();
			BatchesTxtPos[i] = Array();
		}
		for(var i = 0; i < Batches.length; ++i)
		{
			Batches[i] = Array();
		}
		for(nLog = 0; nLog < nNumLogs; nLog++)
		{
			var ThreadName = ThreadNames[nLog];
			if(ThreadsAllActive || ThreadsActive[ThreadName])
			{

				var LodIndex = 0;
				var MinDelta = 0;
				var NextLod = 1;
				while(NextLod < LodData.length && LodData[NextLod].MinDelta[nLog] < nMinTimeMs)
				{
					LodIndex = NextLod;
					NextLod = NextLod + 1;
					MinDelta = LodData[LodIndex].MinDelta[nLog];
				}
				if(LodIndex == LodData.length)
				{
					LodIndex = LodData.length-1;
				}

				context.fillStyle = 'white';
				context.fillText(ThreadName, 0, fOffsetY);
				fOffsetY += BoxHeight;
				if(nContextSwitchEnabled)
				{
					DrawContextSwitchBars(context, ThreadIds[nLog], fScaleX, fOffsetY, fDetailedOffset, nHoverColor, MinWidth, bDrawEnabled);
					fOffsetY += CSwitchHeight+1;
				}
				var MaxDepth = 1;
				var StackPos = 0;
				var Stack = Array(20);
				var Lod = LodData[LodIndex];

				var TypeArray = Lod.TypeArray[nLog];
				var IndexArray = Lod.IndexArray[nLog];
				var TimeArray = Lod.TimeArray[nLog];

				var LocalFirstFrame = Frames[FirstFrame].FirstFrameIndex[nLog];
				var IndexStart = Lod.LogStart[LocalFirstFrame][nLog];
				var IndexEnd = TimeArray.length;
				IndexEnd = TimeArray.length;
				var HasSetHover = 0;


				for(var j = IndexStart; j < IndexEnd; ++j)
				{
					var type = TypeArray[j];
					var index = IndexArray[j];
					var time = TimeArray[j];
					if(type == 1)
					{
						//push
						Stack[StackPos] = time;
						StackPos++;
						if(StackPos > MaxDepth)
						{
							MaxDepth = StackPos;
						}
					}
					else if(type == 0)
					{
						if(StackPos>0)
						{
							StackPos--;

							var timestart = Stack[StackPos];
							var timeend = time;
							var X = (timestart - fDetailedOffset) * fScaleX;
							var Y = fOffsetY + StackPos * BoxHeight;
							var W = (timeend-timestart)*fScaleX;

							if(W > MinWidth && X < nWidth && X+W > 0)
							{
								if(bDrawEnabled || index == nHoverToken)
								{
									Batches[index].push(X);
									Batches[index].push(Y);
									Batches[index].push(W);
									DebugDrawQuadCount++;

									var XText = X < 0 ? 0 : X;
									var WText = W - (XText-X);
									var name = TimerInfo[index].name;
									var len = TimerInfo[index].len;
									var sublen = Math.floor((WText-2)/FontWidth);
									if(sublen >= 2)
									{
										if(sublen < len)
											name = name.substr(0, sublen);
										var txtidx = TimerInfo[index].textcolorindex;
										BatchesTxt[txtidx].push(name);
										BatchesTxtPos[txtidx].push(XText+1);
										BatchesTxtPos[txtidx].push(Y+BoxHeight-FontAscent);

										DebugDrawTextCount++;
									}
								}


								if(DetailedViewMouseX >= X && DetailedViewMouseX <= X+W && DetailedViewMouseY < Y+BoxHeight && DetailedViewMouseY >= Y)
								{
									fRangeBeginNext = timestart;
									fRangeEndNext = timeend;
									nHoverTokenNext = index;
									nHoverTokenIndexNext = j;
									nHoverTokenLogIndexNext = nLog;
									bHasSetHover = 1;
									// nHoverFrame = i;
								}
							}
							if(StackPos == 0 && time > fTimeEnd)
								break;											
						}
					}
				}
				fOffsetY += (1+g_MaxStack[nLog]) * BoxHeight;

				if(HasSetHover)
				{
					for(var i = 0; i < Frames.length-1; ++i)
					{
						var IndexStart = Lod.LogStart[i][nLog];
						if(nHoverTokenNext >= IndexStart)
						{
							nHoverFrame = i;
						}
					}
				}
			}
		}
		{
			for(var i = 0; i < Batches.length; ++i)
			{
				var a = Batches[i];
				if(a.length)
				{
					if(i == nHoverToken)
					{
						context.fillStyle = nHoverColor;
					}
					else
					{
						context.fillStyle = TimerInfo[i].color;
					}
					for(var j = 0; j < a.length; j += 3)
					{						
						var X = a[j];
						var Y = a[j+1];
						var W = a[j+2];
						while(j+1 < a.length)
						{
							var jnext = j+3;
							var XNext = a[jnext];
							var YNext = a[jnext+1];
							var WNext = a[jnext+2];
							var Delta = XNext - (X+W);
							var YDelta = Math.abs(Y - YNext);							
							if(Delta < 0.3 && YDelta < 0.5)
							{
								W = (XNext+WNext) - X;
								j += 3;
							}
							else
							{
								break;
							}

						}
						context.fillRect(X, Y, W, BoxHeight-1);
					}
				}
			}	
		}
		for(var i = 0; i < BatchesTxt.length; ++i)
		{
			context.fillStyle = BatchesTxtColor[i];
			var TxtArray = BatchesTxt[i];
			var PosArray = BatchesTxtPos[i];
			for(var j = 0; j < TxtArray.length; ++j)
			{
				var k = j * 2;
				context.fillText(TxtArray[j], PosArray[k],PosArray[k+1]);
			}
		}

	}
}
function DrawTextBox(context, text, x, y, align)
{
	var textsize = context.measureText(text).width;
	var offsetx = 0;
	var offsety = -FontHeight;
	if(align == 'center')
	{
		offsetx = -textsize / 2.0;
	}
	else if(align == 'right')
	{
		offsetx = -textsize;
	}
	context.fillStyle = nBackColors[0];
	context.fillRect(x + offsetx, y + offsety, textsize+2, FontHeight + 2);
	context.fillStyle = 'white';
	context.fillText(text, x, y);

}
function DrawDetailed(Animation)
{
	if(AnimationActive != Animation || !Initialized)
	{
		return;
	}
	ProfileEnter("DrawDetailed");
	DebugDrawQuadCount = 0;
	DebugDrawTextCount = 0;
	nHoverCSCpuNext = -1;

	fRangeBeginNext = fRangeEndNext = -1;

	var start = new Date();
	nDrawCount++;

	var context = CanvasDetailedView.getContext('2d');
	var offscreen = CanvasDetailedOffscreen.getContext('2d');
	var fScaleX = nWidth / fDetailedRange; 
	var fOffsetY = -nOffsetY + BoxHeight;

	if(DetailedRedrawState.fOffsetY == fOffsetY && DetailedRedrawState.fDetailedOffset == fDetailedOffset && DetailedRedrawState.fDetailedRange == fDetailedRange && !KeyCtrlDown && !KeyShiftDown && !MouseDragButton)
	{
		Invalidate++;
	}
	else
	{
		Invalidate = 0;
		DetailedRedrawState.fOffsetY = fOffsetY;
		DetailedRedrawState.fDetailedOffset = fDetailedOffset;
		DetailedRedrawState.fDetailedRange = fDetailedRange;
	}
	if(Invalidate == 0) //when panning, only draw bars that are a certain width to keep decent framerate
	{
		context.clearRect(0, 0, CanvasDetailedView.width, CanvasDetailedView.height);
		DrawDetailedView(context, nMinWidthPan, true);
	}
	else if(Invalidate == 1) //draw full and store
	{
		offscreen.clearRect(0, 0, CanvasDetailedView.width, CanvasDetailedView.height);
		DrawDetailedView(offscreen, nMinWidth, true);
		OffscreenData = offscreen.getImageData(0, 0, CanvasDetailedOffscreen.width, CanvasDetailedOffscreen.height);
	}
	else//reuse stored result untill next time viewport is changed.
	{
		context.clearRect(0, 0, CanvasDetailedView.width, CanvasDetailedView.height);
		context.putImageData(OffscreenData, 0, 0);
		DrawDetailedView(context, nMinWidth, false);
	}

	if(KeyShiftDown || KeyCtrlDown || MouseDragButton || MouseDragSelectRange())
	{
		nHoverToken = -1;
		nHoverTokenIndex = -1;
		nHoverTokenLogIndex = -1;

		if(!MouseDragSelectRange())
		{
			fRangeBegin = fRangeEnd = -1;
		}
	}
	else
	{
		nHoverToken = nHoverTokenNext;
		nHoverTokenIndex = nHoverTokenIndexNext;
		nHoverTokenLogIndex = nHoverTokenLogIndexNext;
		if(fRangeBeginHistory < fRangeEndHistory)
		{
			fRangeBegin = fRangeBeginHistory;
			fRangeEnd = fRangeEndHistory;
		}
		else
		{
			fRangeBegin = fRangeBeginNext;
			fRangeEnd = fRangeEndNext;
		}
	}
	if(fRangeBegin < fRangeEnd)
	{
		var X = (fRangeBegin - fDetailedOffset) * fScaleX;
		var Y = 0;
		var W = (fRangeEnd - fRangeBegin) * fScaleX;
		context.globalAlpha = 0.1;
		context.fillStyle = '#009900';
		context.fillRect(X, Y, W, nHeight);
		context.globalAlpha = 1;
		context.strokeStyle = '#00ff00';
		context.beginPath();
		context.moveTo(X, Y);
		context.lineTo(X, Y+nHeight);
		context.moveTo(X+W, Y);
		context.lineTo(X+W, Y+nHeight);
		context.stroke();
		var Duration = (fRangeEnd - fRangeBegin).toFixed(2) + "ms";
		var Center = ((fRangeBegin + fRangeEnd) / 2.0) - fDetailedOffset;
		var DurationWidth = context.measureText(Duration+ "   ").width;

		context.fillStyle = 'white';
		context.textAlign = 'right';
		DrawTextBox(context, '' + fRangeBegin.toFixed(2), X-3, 9, 'right');
		if(DurationWidth < W + 10)
		{
			context.textAlign = 'center';
			DrawTextBox(context,'' + Duration,Center * fScaleX, 9, 'center');

			var W0 = W - DurationWidth + FontWidth*1.5;
			if(W0 > 6)
			{
				var Y0 = Y + FontHeight * 0.5;
				W0 = W0 / 2.0;
				var X0 = X + W0;
				var X1 = X + W - W0;
				context.strokeStyle = '#00ff00';
				context.beginPath();
				context.moveTo(X, Y0);
				context.lineTo(X0, Y0);
				context.moveTo(X0, Y0-2);
				context.lineTo(X0, Y0+2);
				context.moveTo(X1, Y0-2);
				context.lineTo(X1, Y0+2);
				context.moveTo(X1, Y0);
				context.lineTo(X + W, Y0);
				context.stroke();
			}
		}
		context.textAlign = 'left';
		DrawTextBox(context, '' + fRangeEnd.toFixed(2), X + W + 2, 9, 'left');
	}
	nHoverCSCpu = nHoverCSCpuNext;
	ProfileLeave();
}

function ZoomTo(fZoomBegin, fZoomEnd)
{
	if(fZoomBegin < fZoomEnd)
	{
		AnimationActive = true;
		var fDetailedOffsetOriginal = fDetailedOffset;
		var fDetailedRangeOriginal = fDetailedRange;
		var fDetailedOffsetTarget = fZoomBegin;
		var fDetailedRangeTarget = fZoomEnd - fZoomBegin;
		var TimestampStart = new Date();
		var count = 0;
		function ZoomFunc(Timestamp)
		{
			var fPrc = (new Date() - TimestampStart) / (ZOOM_TIME * 1000.0);
			if(fPrc > 1.0)
			{
				fPrc = 1.0;
			}
			fPrc = Math.pow(fPrc, 0.3);
			fDetailedOffset = fDetailedOffsetOriginal + (fDetailedOffsetTarget - fDetailedOffsetOriginal) * fPrc;
			fDetailedRange = fDetailedRangeOriginal + (fDetailedRangeTarget - fDetailedRangeOriginal) * fPrc;
			DrawDetailed(true);
			if(fPrc >= 1.0)
			{
				AnimationActive = false;
				fDetailedOffset = fDetailedOffsetTarget;
				fDetailedRange = fDetailedRangeTarget;
			}
			else
			{
				requestAnimationFrame(ZoomFunc);
			}
		}
		requestAnimationFrame(ZoomFunc);
	}
}
function RequestRedraw()
{
	Invalidate = 0;
	Draw();
}
function Draw()
{
	if(ProfileMode)
	{
		ProfileModeClear();
		ProfileEnter("Total");
	}

	if(Mode == ModeTimers)
	{
		DrawBarView();
		DrawHoverToolTip();
	}
	else if(Mode == ModeDetailed)
	{
		DrawDetailed(false);
		DrawHoverToolTip();
	}

	DrawDetailedFrameHistory();

	if(ProfileMode)
	{
		ProfileLeave();
		ProfileModeDraw(CanvasDetailedView);
	}
}

function AutoRedraw(Timestamp)
{
	if(Mode == ModeDetailed)
	{
		if(ProfileMode == 2 || ((nHoverCSCpu >= 0 || nHoverToken != -1) && !KeyCtrlDown && !KeyShiftDown && !MouseDragButton)||(Invalidate<2 && !KeyCtrlDown && !KeyShiftDown && !MouseDragButton))
		{
			Draw(1);
		}
	}
	else
	{
		if(Invalidate < 1)
		{
			Draw(1);
		}


	}
	requestAnimationFrame(AutoRedraw);
}


function ZoomGraph(nZoom)
{
	var fOldRange = fDetailedRange;
	if(nZoom>0)
	{
		fDetailedRange *= Math.pow(nModDown ? 1.40 : 1.03, nZoom);
	}
	else
	{
		var fNewDetailedRange = fDetailedRange / Math.pow((nModDown ? 1.40 : 1.03), -nZoom);
		if(fNewDetailedRange < 0.0001) //100ns
			fNewDetailedRange = 0.0001;
		fDetailedRange = fNewDetailedRange;
	}

	var fDiff = fOldRange - fDetailedRange;
	var fMousePrc = DetailedViewMouseX / nWidth;
	if(fMousePrc < 0)
	{
		fMousePrc = 0;
	}
	fDetailedOffset += fDiff * fMousePrc;

}

function MeasureFont()
{
	var context = CanvasDetailedView.getContext('2d');
	context.font = Font;
	FontWidth = context.measureText('W').width;

}
function ResizeCanvas() 
{
	nWidth = window.innerWidth;
	nHeight = window.innerHeight - CanvasHistory.height-2;
	DPR = window.devicePixelRatio;

	if(DPR)
	{
		CanvasDetailedView.style.width = nWidth + 'px'; 
		CanvasDetailedView.style.height = nHeight + 'px';
		CanvasDetailedView.width = nWidth * DPR;
		CanvasDetailedView.height = nHeight * DPR;
		CanvasHistory.style.width = window.innerWidth + 'px';
		CanvasHistory.style.height = 70 + 'px';
		CanvasHistory.width = window.innerWidth * DPR;
		CanvasHistory.height = 70 * DPR;
		CanvasHistory.getContext('2d').scale(DPR,DPR);
		CanvasDetailedView.getContext('2d').scale(DPR,DPR);

		CanvasDetailedOffscreen.style.width = nWidth + 'px';
		CanvasDetailedOffscreen.style.height = nHeight + 'px';
		CanvasDetailedOffscreen.width = nWidth * DPR;
		CanvasDetailedOffscreen.height = nHeight * DPR;
		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);

	}
	else
	{
		DPR = 1;
		CanvasDetailedView.width = nWidth;
		CanvasDetailedView.height = nHeight;
		CanvasDetailedOffscreen.width = nWidth;
		CanvasDetailedOffscreen.height = nHeight;
		CanvasHistory.width = window.innerWidth;
	}
	RequestRedraw();
}

var MouseDragOff = 0;
var MouseDragDown = 1;
var MouseDragUp = 2;
var MouseDragMove = 3;
var MouseDragState = MouseDragOff;
var MouseDragTarget = 0;
var MouseDragButton = 0;
var MouseDragKeyShift = 0;
var MouseDragKeyCtrl = 0;
var MouseDragX = 0;
var MouseDragY = 0;
var MouseDragXLast = 0;
var MouseDragYLast = 0;
var MouseDragXStart = 0;
var MouseDragYStart = 0;

function clamp(number, min, max)
{
  return Math.max(min, Math.min(number, max));
}

function MouseDragPan()
{
	return MouseDragButton == 1 || MouseDragKeyShift;
}
function MouseDragSelectRange()
{
	return MouseDragState == MouseDragMove && (MouseDragButton == 3 || (MouseDragKeyShift && MouseDragKeyCtrl));
}
function MouseHandleDrag()
{
	if(MouseDragTarget == CanvasDetailedView)
	{
		if(Mode == ModeDetailed)
		{
			if(MouseDragSelectRange())
			{
				var xStart = MouseDragXStart;
				var xEnd = MouseDragX;
				if(xStart > xEnd)
				{
					var Temp = xStart;
					xStart = xEnd;
					xEnd = Temp;
				}
				if(xEnd - xStart > 1)
				{
					fRangeBegin = fDetailedOffset + fDetailedRange * (xStart / nWidth);
					fRangeEnd = fDetailedOffset + fDetailedRange * (xEnd / nWidth);
				}
			}
			else if(MouseDragPan())
			{
				var X = MouseDragX - MouseDragXLast;
				var Y = MouseDragY - MouseDragYLast;
				if(X)
				{
					fDetailedOffset += -X * fDetailedRange / nWidth;
				}
				nOffsetY -= Y;
				if(nOffsetY < 0)
				{
					nOffsetY = 0;
				}
			}
			else if(MouseDragKeyCtrl)
			{
				if(MouseDragY != MouseDragYLast)
				{
					ZoomGraph(MouseDragY - MouseDragYLast);
				}
			}
		}
		else if(Mode == ModeTimers)
		{
			if(MouseDragKeyShift || MouseDragButton == 1)
			{
				var X = MouseDragX - MouseDragXLast;
				var Y = MouseDragY - MouseDragYLast;
				nOffsetBarsY -= Y;
				if(nOffsetBarsY < 0)
				{
					nOffsetBarsY = 0;
				}
			}

		}

	}
	else if(MouseDragTarget == CanvasHistory)
	{
		function HistoryFrameTime(x)
		{
			var NumFrames = Frames.length;
			var fBarWidth = nWidth / NumFrames;
			var Index = clamp(Math.floor(NumFrames * x / nWidth), 0, NumFrames-1);
			var Lerp = clamp((x/fBarWidth - Index) , 0, 1);
			var time = Frames[Index].framestart + (Frames[Index].frameend - Frames[Index].framestart) * Lerp;
			return time;
		}
		if(MouseDragSelectRange())
		{
			fRangeBegin = fRangeEnd = -1;

			var xStart = MouseDragXStart;
			var xEnd = MouseDragX;
			if(xStart > xEnd)
			{
				var Temp = xStart;
				xStart = xEnd;
				xEnd = Temp;
			}
			if(xEnd - xStart > 2)
			{
				var timestart = HistoryFrameTime(xStart);
				var timeend = HistoryFrameTime(xEnd);
				fDetailedOffset = timestart;
				fDetailedRange = timeend-timestart;
			}
		}
		else if(MouseDragPan())
		{
			var Time = HistoryFrameTime(MouseDragX);
			fDetailedOffset = Time - fDetailedRange / 2.0;
		}
	}
}
function MouseHandleDragEnd()
{
	if(MouseDragTarget == CanvasDetailedView)
	{
		if(MouseDragSelectRange())
		{
			ZoomTo(fRangeBegin, fRangeEnd);
			fRangeBegin = fRangeEnd = -1;
		}
	}
	else if(MouseDragTarget == CanvasHistory)
	{
		if(!MouseDragSelectRange() && !MouseDragPan())
		{
			ZoomTo(fRangeBegin, fRangeEnd);
			fRangeBegin = fRangeEnd = -1;
		}


	}

}

function MouseHandleDragClick()
{
	if(MouseDragTarget == CanvasDetailedView)
	{
		ZoomTo(fRangeBegin, fRangeEnd);
	}
	else if(MouseDragTarget == CanvasHistory)
	{
		if(Mode == ModeDetailed)
		{
			ZoomTo(fRangeBegin, fRangeEnd);
		}
	}
}

function MapMouseButton(Event)
{
	if(event.button == 1 || event.which == 1)
	{
		return 1;
	}
	else if(event.button == 3 || event.which == 3)
	{
		return 3;
	}
	else
	{
		return 0;
	}
}

function MouseDragReset()
{
	MouseDragState = MouseDragOff;
	MouseDragTarget = 0;
	MouseDragKeyShift = 0;
	MouseDragKeyCtrl = 0;
	MouseDragButton = 0;
}
function MouseDragKeyUp()
{
	if((MouseDragKeyShift && !KeyShiftDown) || (MouseDragKeyCtrl && !KeyCtrlDown))
	{
		MouseHandleDragEnd();
		MouseDragReset();
	}
}
function MouseDrag(Source, Event)
{
	if(Source == MouseDragOff || (MouseDragTarget && MouseDragTarget != Event.target))
	{
		MouseDragReset();
		return;
	}

	var LocalRect = Event.target.getBoundingClientRect();
	MouseDragX = Event.clientX - LocalRect.left;
	MouseDragY = Event.clientY - LocalRect.top;
	// console.log('cur drag state ' + MouseDragState + ' Source ' + Source);
	if(MouseDragState == MouseDragMove)
	{
		var dx = Math.abs(MouseDragX - MouseDragXStart);
		var dy = Math.abs(MouseDragY - MouseDragYStart);
		if((Source == MouseDragUp && MapMouseButton(Event) == MouseDragButton) ||
			(MouseDragKeyCtrl && !KeyCtrlDown) ||
			(MouseDragKeyShift && !KeyShiftDown))
		{
			MouseHandleDragEnd();
			MouseDragReset();
			return;
		}
		else
		{
			MouseHandleDrag();
		}
	}
	else if(MouseDragState == MouseDragOff)
	{
		if(Source == MouseDragDown || KeyShiftDown || KeyCtrlDown)
		{
			MouseDragTarget = Event.target;
			MouseDragButton = MapMouseButton(Event);
			MouseDragState = MouseDragDown;
			MouseDragXStart = MouseDragX;
			MouseDragYStart = MouseDragY;
			MouseDragKeyCtrl = 0;
			MouseDragKeyShift = 0;

			if(KeyShiftDown || KeyCtrlDown)
			{
				MouseDragKeyShift = KeyShiftDown;
				MouseDragKeyCtrl = KeyCtrlDown;
				MouseDragState = MouseDragMove;
			}
		}
	}
	else if(MouseDragState == MouseDragDown)
	{
		if(Source == MouseDragUp)
		{
			MouseHandleDragClick();
			MouseDragReset();
		}
		else if(Source == MouseDragMove)
		{
			var dx = Math.abs(MouseDragX - MouseDragXStart);
			var dy = Math.abs(MouseDragY - MouseDragYStart);
			if(dx+dy>1)
			{
				MouseDragState = MouseDragMove;
			}
		}
	}
	MouseDragXLast = MouseDragX;
	MouseDragYLast = MouseDragY;
}

function MouseMove(evt)
{
    evt.preventDefault();
    MouseDrag(MouseDragMove, evt);
 	MouseHistory = 0;
	MouseDetailed = 0;
	HistoryViewMouseX = HistoryViewMouseY = -1;
	var rect = evt.target.getBoundingClientRect();
	var x = evt.clientX - rect.left;
	var y = evt.clientY - rect.top;
	if(evt.target == CanvasDetailedView)
	{
		if(!MouseDragSelectRange())
		{
			fRangeBegin = fRangeEnd = -1;
		}
		DetailedViewMouseX = x;
		DetailedViewMouseY = y;
	}
	else if(evt.target = CanvasHistory)
	{
		var Rect = CanvasHistory.getBoundingClientRect();
		HistoryViewMouseX = x;
		HistoryViewMouseY = y;
	}
	Draw();
}

function MouseButton(bPressed, evt)
{
    evt.preventDefault();
	MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
}

function MouseOut(evt)
{
	MouseDrag(MouseDragOff, evt);
	KeyCtrlDown = 0;
	KeyShiftDown = 0;
	MouseDragButton = 0;
	nHoverToken = -1;
	fRangeBegin = fRangeEnd = -1;
}

function MouseWheel(e)
{
    var e = window.event || e;
    var delta = (e.wheelDelta || e.detail * (-120));
    ZoomGraph((-4 * delta / 120.0) | 0);
    Draw();
}


function KeyUp(evt)
{
	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 0;
		MouseDragKeyUp();
	}
	else if(evt.keyCode == 16)
	{
		KeyShiftDown = 0;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 18)
	{
		FlipToolTip = 0;
	}
	Invalidate = 0;

}

function KeyDown(evt)
{
	if(evt.keyCode == 18)
	{
		FlipToolTip = 1;
	}
	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 1;
	}
	else if(evt.keyCode == 16)
	{
		KeyShiftDown = 1;
	}
	Invalidate = 0;
}

function ReadCookie()
{
	var result = document.cookie.match(/fisk=([^;]+)/);
	var NewMode = ModeDetailed;
	var ReferenceTimeString = '33ms';
	if(result && result.length > 0)
	{
		var Obj = JSON.parse(result[1]);
		if(Obj.Mode)
		{
			NewMode = Obj.Mode;
		}
		if(Obj.ReferenceTime)
		{
			ReferenceTimeString = Obj.ReferenceTime;
		}
		if(Obj.ThreadsAllActive || Obj.ThreadsAllActive == 0 || Obj.ThreadsAllActive == false)
		{
			ThreadsAllActive = Obj.ThreadsAllActive;
		}
		else
		{
			ThreadsAllActive = 1;
		}
		if(Obj.ThreadsActive)
		{
			ThreadsActive = Obj.ThreadsActive;
		}
		if(Obj.GroupsAllActive || Obj.GroupsAllActive == 0 || Obj.GroupsAllActive)
		{
			GroupsAllActive = Obj.GroupsAllActive;
		}
		else
		{
			GroupsAllActive = 1;
		}
		if(Obj.GroupsActive)
		{
			GroupsActive = Obj.GroupsActive;
		}
		if(Obj.nContextSwitchEnabled)
		{
			nContextSwitchEnabled = Obj.nContextSwitchEnabled; 
		}
		else
		{
			nContextSwitchEnabled = 1;
		}
		TimersGroups = Obj.TimersGroups?1:0;
		TimersMeta = Obj.TimersMeta?0:1;
	}
	SetContextSwitch(nContextSwitchEnabled);
	SetMode(NewMode, TimersGroups);
	SetReferenceTime(ReferenceTimeString);
	UpdateTimersOptions();
}
function WriteCookie()
{
	var Obj = new Object();
	Obj.Mode = Mode;
	Obj.ReferenceTime = ReferenceTime + 'ms';
	Obj.ThreadsActive = ThreadsActive;
	Obj.ThreadsAllActive = ThreadsAllActive;
	Obj.GroupsActive = GroupsActive;
	Obj.GroupsAllActive = GroupsAllActive;
	Obj.nContextSwitchEnabled = nContextSwitchEnabled;
	Obj.TimersGroups = TimersGroups?1:0;
	Obj.TimersMeta = TimersMeta?0:1;
	var date = new Date();
	date.setFullYear(2099);
	var cookie = 'fisk=' + JSON.stringify(Obj) + ';expires=' + date;
	document.cookie = cookie;
}

var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x

CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
CanvasDetailedView.addEventListener('mouseout', MouseOut);
CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
CanvasHistory.addEventListener('mousemove', MouseMove);
CanvasHistory.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
CanvasHistory.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
CanvasHistory.addEventListener('mouseout', MouseOut);
CanvasHistory.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
CanvasHistory.addEventListener(mousewheelevt, MouseWheel, false);
window.addEventListener('keydown', KeyDown);
window.addEventListener('keyup', KeyUp);
window.addEventListener('resize', ResizeCanvas, false);

function CalcAverage()
{
	var Sum = 0;
	var Count = 0;
	for(nLog = 0; nLog < nNumLogs; nLog++)
	{
		StackPos = 0;
		for(var i = 0; i < Frames.length; i++)
		{
			var Frame_ = Frames[i];			
			var tt = Frame_.tt[nLog];
			var ts = Frame_.ts[nLog];

			var count = tt.length;
			for(var j = 0; j < count; j++)
			{
				var type = tt[j];
				var time = ts[j];
				if(type == 1)
				{
					Stack[StackPos] = time;//store the frame which it comes from
					StackPos++;
				}
				else if(type == 0)
				{
					if(StackPos>0)
					{

						StackPos--;
						var localtime = time - Stack[StackPos];
						Count++;
						Sum += localtime;
					}
				}
			}
		}
	}
	return Sum / Count;

}

function MakeLod(index, MinDelta, TimeArray, TypeArray, IndexArray, LogStart)
{
	if(LodData[index])
	{
		console.log("error!!");
	}
	// debugger;
	var o = new Object();
	o.MinDelta = MinDelta;
	o.TimeArray = TimeArray;
	o.TypeArray = TypeArray;
	o.IndexArray = IndexArray;
	o.LogStart = LogStart;
	LodData[index] = o;
}

function PreprocessBuildSplitArray()
{
	var nNumLogs = Frames[0].ts.length;

	ProfileEnter("PreprocessBuildSplitArray");
	var SplitArrays = new Array(nNumLogs);

	for(nLog = 0; nLog < nNumLogs; ++nLog)
	{
		console.log("source log " + nLog + " size " + LodData[0].TypeArray[nLog].length);
	}


	for(nLog = 0; nLog < nNumLogs; nLog++)
	{
		var MaxDepth = 1;
		var StackPos = 0;
		var Stack = Array(20);
		var TypeArray = LodData[0].TypeArray[nLog];
		var TimeArray = LodData[0].TimeArray[nLog];
		var DeltaTimes = new Array(TypeArray.length);

		for(var j = 0; j < TypeArray.length; ++j)
		{
			var type = TypeArray[j];
			var time = TimeArray[j];
			if(type == 1)
			{
				//push
				Stack[StackPos] = time;
				StackPos++;
			}
			else if(type == 0)
			{
				if(StackPos>0)
				{
					StackPos--;
					DeltaTimes[j] = time - Stack[StackPos];
				}
				else
				{
					DeltaTimes[j] = 0;
				}
			}
		}
		DeltaTimes.sort(function(a,b){return b-a;});
		var SplitArray = Array(NumLodSplits);
		var SplitIndex = DeltaTimes.length;

		var j = 0;
		for(j = 0; j < NumLodSplits; ++j)
		{
			SplitIndex = Math.floor(SplitIndex / 2);
			while(SplitIndex > 0 && !DeltaTimes[SplitIndex])
			{
				SplitIndex--;
			}
			if(SplitIndex < SplitMin)
			{
				break;
			}
			//search.. if 0
			var SplitTime = DeltaTimes[SplitIndex];
			if(SplitTime>=0)
			{
				SplitArray[j] = SplitTime;
			}
			else
			{
				SplitArray[j] = SPLIT_LIMIT;
			}
			if(j>0)
			{
				console.assert(SplitArray[j-1] <= SplitArray[j], "must be less");
			}

		}
		for(; j < NumLodSplits; ++j)
		{
			SplitArray[j] = SPLIT_LIMIT;
			// console.log("split skipping " + j + " " + SPLIT_LIMIT);
		}


		SplitArrays[nLog] = SplitArray;
	}
	ProfileLeave();
	return SplitArrays;
}

function PreprocessBuildDurationArray()
{
	var nNumLogs = Frames[0].ts.length;
	ProfileEnter("PreprocessBuildDurationArray");
	var DurationArrays = new Array(nNumLogs);
	for(nLog = 0; nLog < nNumLogs; ++nLog)
	{
		var MaxDepth = 1;
		var StackPos = 0;
		var Stack = Array(20);
		var StackIndex = Array(20);
		var TypeArray = LodData[0].TypeArray[nLog];
		var TimeArray = LodData[0].TimeArray[nLog];
		var DurationArray = Array(LodData[0].TypeArray[nLog].length);
		for(var j = 0; j < TypeArray.length; ++j)
		{
			var type = TypeArray[j];
			var time = TimeArray[j];
			if(type == 1)
			{
				//push
				Stack[StackPos] = time;
				StackIndex[StackPos] = j;
				StackPos++;
			}
			else if(type == 0)
			{
				if(StackPos>0)
				{
					StackPos--;
					var Duration = time - Stack[StackPos];
					DurationArray[StackIndex[StackPos]] = Duration;
					DurationArray[j] = Duration;
				}
				else
				{
					DurationArray[j] = 0;
				}
			}
		}
		for(var j = 0; j < StackPos; ++j)
		{
			DurationArray[j] = 0;
		}
		DurationArrays[nLog] = DurationArray;
	}
	ProfileLeave();
	return DurationArrays;

}
function PreprocessLods()
{
	ProfileEnter("PreprocessLods");
	var nNumLogs = Frames[0].ts.length;
	// debugger;
	var SplitArrays = PreprocessBuildSplitArray();
	var DurationArrays = PreprocessBuildDurationArray();
	var Source = LodData[0];
	var SourceLogStart = Source.LogStart;
	var NumFrames = SourceLogStart.length;

	for(var i = 0; i < NumLodSplits-1; ++i)
	{
		// debugger;
		// console.log("doing lod split " + i);
		// var LodObject = new Object();
		var DestLogStart = Array(SourceLogStart.length);
		for(var j = 0; j < DestLogStart.length; ++j)
		{
			DestLogStart[j] = Array(nNumLogs);
			// console.log("destlogstart " + j + " " + DestLogStart[j].length);
		}
		//LodObject.LogStart = DestLogStart;
		var MinDelta = Array(nNumLogs);
		var TimeArray = Array(nNumLogs);
		var IndexArray = Array(nNumLogs);
		var TypeArray = Array(nNumLogs);



		for(nLog = 0; nLog < nNumLogs; ++nLog)
		{
			var SourceTypeArray = Source.TypeArray[nLog];
			var SourceTimeArray = Source.TimeArray[nLog];
			var SourceIndexArray = Source.IndexArray[nLog];
			var Duration = DurationArrays[nLog];
			console.assert(Duration.length == SourceTypeArray.length, "must be equal!");
			var SplitTime = SplitArrays[nLog][i];

			MinDelta[nLog] = SplitTime;
			if(SplitTime < SPLIT_LIMIT)
			{
				var SourceCount = SourceTypeArray.length;
				var DestTypeArray = Array();
				var DestTimeArray = Array();
				var DestIndexArray = Array();
				var RemapArray = Array(SourceCount);

				for(var j = 0; j < SourceCount; ++j)
				{
					if(Duration[j] >= SplitTime)
					{
						DestTypeArray.push(SourceTypeArray[j]);
						DestTimeArray.push(SourceTimeArray[j]);
						DestIndexArray.push(SourceIndexArray[j]);
					}
					RemapArray[j] = DestTypeArray.length;
				}
				TimeArray[nLog] = DestTimeArray;
				IndexArray[nLog] = DestIndexArray;
				TypeArray[nLog] = DestTypeArray;
				var j;
				for(var j = 0; j < NumFrames; ++j)
				{
					var OldStart = SourceLogStart[j][nLog];
					var NewStart = RemapArray[OldStart];
					var FrameArray = DestLogStart[j];
					FrameArray[nLog] = NewStart;
				}
			}
			else
			{

				for(var j = 0; j < NumFrames; ++j)
				{
					var FrameArray = DestLogStart[j];
	
					FrameArray[nLog] = 0;
				}

			}

		}
		MakeLod(i+1, MinDelta, TimeArray, TypeArray, IndexArray, DestLogStart);
	}
	ProfileLeave();
}
function PreprocessGlobalArray()
{
	ProfileEnter("PreprocessGlobalArray");
	var nNumLogs = Frames[0].ts.length;
	g_TypeArray = new Array(nNumLogs);
	g_TimeArray = new Array(nNumLogs);
	g_IndexArray = new Array(nNumLogs);
	var StackPos = 0;
	var Stack = Array(20);
	var LogStartArray = new Array(Frames.length);
	for(var i = 0; i < Frames.length; i++)
	{
		Frames[i].LogStart = new Array(nNumLogs);	
		LogStartArray[i] = Frames[i].LogStart;

		Frames[i].LogEnd = new Array(nNumLogs);
	}
	var MinDelta = Array(nNumLogs);
	for(nLog = 0; nLog < nNumLogs; nLog++)
	{
		MinDelta[nLog] = 0;
		var TypeArray = new Array();
		var TimeArray = new Array();
		var IndexArray = new Array();
		for(var i = 0; i < Frames.length; i++)
		{
			var Frame_ = Frames[i];	
			Frame_.LogStart[nLog] = TimeArray.length;
			Frame_.LogEnd[nLog] = Frame_.tt[nLog].length + TimeArray.length;
			TypeArray = TypeArray.concat(Frame_.tt[nLog]);
			TimeArray = TimeArray.concat(Frame_.ts[nLog]);
			IndexArray = IndexArray.concat(Frame_.ti[nLog]);
			// console.log(" " + TypeArray.length + " added " + Frame_.tt[nLog].length);
			if(Frame_.tt.length != Frame_.ts.length || Frame_.ti.length != Frame_.ts.length)
			{
				console.log("ERRROR");
			}
		}
		g_TypeArray[nLog] = TypeArray;
		g_TimeArray[nLog] = TimeArray;
		g_IndexArray[nLog] = IndexArray;
	}
	MakeLod(0, MinDelta, g_TimeArray, g_TypeArray, g_IndexArray, LogStartArray);
	ProfileLeave();
}

function PreprocessFindFirstFrames()
{
	ProfileEnter("PreprocesFindFirstFrames");
	//create arrays that show how far back we need to start search in order to get all markers.
	var nNumLogs = Frames[0].ts.length;
	for(var i = 0; i < Frames.length; i++)
	{
		Frames[i].FirstFrameIndex = new Array(nNumLogs);
	}

	var StackPos = 0;
	var Stack = Array(20);
	g_MaxStack = Array(nNumLogs);
	
	for(nLog = 0; nLog < nNumLogs; nLog++)
	{
		var MaxStack = 0;
		StackPos = 0;
		for(var i = 0; i < Frames.length; i++)
		{
			var Frame_ = Frames[i];			
			var tt = Frame_.tt[nLog];
			var count = tt.length;

			var FirstFrame = i;
			if(StackPos>0)
			{
				FirstFrame = Stack[0];
			}
			Frames[i].FirstFrameIndex[nLog] = FirstFrame;

			for(var j = 0; j < count; j++)
			{
				var type = tt[j];
				if(type == 1)
				{
					Stack[StackPos] = i;//store the frame which it comes from
					StackPos++;
					if(StackPos > MaxStack)
					{
						MaxStack = StackPos;
					}
				}
				else if(type == 0)
				{
					if(StackPos>0)
					{
						StackPos--;
					}
				}
			}
		}
		g_MaxStack[nLog] = MaxStack;
	}
	ProfileLeave();
}
function Preprocess()
{
	var ProfileModeOld = ProfileMode;
	ProfileMode = 1;
	ProfileModeClear();
	ProfileEnter("Preprocess");
	for(var i = 0; i < TimerInfo.length; i++)
	{
		var v = CalculateTimers(TimerInfo[i], i);
	}
	PreprocessFindFirstFrames();
	PreprocessGlobalArray();
	PreprocessLods();
	ProfileLeave();
	ProfileModeDump();
	ProfileMode = ProfileModeOld;
	Initialized = 1;
}

InitGroups();
ReadCookie();
MeasureFont()
InitThreadMenu();
InitGroupMenu();
InitFrameInfo();
UpdateThreadMenu();
ResizeCanvas();
Preprocess();
Draw();
AutoRedraw();

</script>
</body>
</html>      